<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>社交网络分析 on 大邓和他的PYTHON</title>
    <link>/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 社交网络分析 on 大邓和他的PYTHON</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 07 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ManagementScience | 使用网络算法识别创新的颠覆性与否</title>
      <link>https://textdata.cn/blog/2022-09-07-management-science-disrupt-science-and-technology/</link>
      <pubDate>Wed, 07 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022-09-07-management-science-disrupt-science-and-technology/</guid>
      <description>The CD index is a new approach to finding important points in evolving networks. When applied to large-scale data sets like U.S. patent citations, the index is useful for identifying influential innovations and other features of technological change.</description>
      <content:encoded><![CDATA[


<p>颠覆式创新是一个很火的概念，在创新创业、科学学等研究中，每个专利、论文的正文中都会引用关系，而引用关系会构成一个引用网络。</p>
<p>那么创新如何从网络形态进行区分，如何计算网络节点的创新程度，本文列举两篇与此相关的论文，分别是 Management science 和 Science 。</p>
<p><br><br></p>
<div id="文献摘要" class="section level2">
<h2>文献摘要</h2>
<p><strong>Funk, Russell J., and Jason Owen-Smith. “A dynamic network measure of technological change.” <em>Management science</em> 63, no. 3 (2017): 791-817.</strong></p>
<p>该文使用网络分析方法研究技术变革，论文认为 <strong>颠覆性的新发明，通过将发明者的注意力转移到或远离这些发明所依赖的知识，来重塑相互关联的技术网络。即更广的视野或更久远的视角，往往有利于颠覆性创新的产生</strong>。<strong>基于该思路，本文开发了新发明的颠覆性与否的计算指标cdindex</strong>。我们将这些指标应用于大学研究商业化的分析，并发现 <strong>联邦研究资金推动校园产生颠覆性创新，而商业联系会有利于巩固现状的创新</strong>。通过量化新技术，我们提出的指数允许基于专利的创新研究捕捉概念上重要的现象， 这些现象无法通过既定措施检测到。该测量方法提供了支持创新、创业、技术战略、科学政策和社会网络理论研究的理论发展的经验见解。</p>
<blockquote>
<p>Abstract: This article outlines a network approach to the study of technological change. We propose that new inventions reshape networks of interlinked technologies by shifting inventors’ attention to or away from the knowledge on which those inventions build. Using this approach, we develop novel indexes of the extent to which a new invention consolidates or destabilizes existing technology streams. We apply these indexes in analyses of university research commercialization and ﬁnd that, although federal research funding pushes campuses to create inventions that are more destabilizing, deeper commercial ties lead them to produce technologies that consolidate the status quo. By quantifying the eﬀects that new technologies have on their predecessors, the indexes we propose allow patent-based studies of innovation to capture conceptually important phenomena that are not detectable with established measures. The measurement approach presented here oﬀers empirical insights that support theoretical development in studies of innovation, entrepreneurship, technology strategy, science policy, and social network theory.</p>
</blockquote>
<p><br></p>
<p><strong>Wu, Lingfei, Dashun Wang, and James A. Evans. “Large teams develop and small teams disrupt science and technology.” Nature 566, no. 7744 (2019): 378-382.</strong></p>
<p>当今科学和技术最普遍的趋势之一是各个领域的大型团队的增长，因为孤独的研究人员和小型团队的流行程度正在减少 。团队规模的增加归因于科学活动的专业化、通信技术的改进 或需要跨学科解决方案的现代问题的复杂性。团队规模的这种转变引发了一个问题，即大团队所产生的科技特征是否以及如何不同于小团队。分析了 1954-2014 年期间超过 6500 万篇论文、专利和软件产品，证明在此期间，<strong>较小的团队倾向于将拉长到更大的时间尺度，借鉴过去，用新的想法和机会来颠覆科学和技术；而较大的团队倾向于聚焦于当前流行的，完善当前现有的</strong>。不论团队大小，均对于蓬勃发展的科学技术生态至关重要，并表明，为实现这一目标，科学政策应旨在支持团队规模的多样性。</p>
<blockquote>
<p>Abstract: One of the most universal trends in science and technology today is the growth of large teams in all areas, as solitary researchers and small teams diminish in prevalence. Increases in team size have been attributed to the specialization of scientific activities,
improvements in communication technology, or the complexity
of modern problems that require interdisciplinary solutions.This shift in team size raises the question of whether and how the character of the science and technology produced by large teams differs from that of small teams. Here we analyse more than 65 million papers, patents and software products that span the period 1954–2014, and demonstrate that across this period smaller teams have tended to disrupt science and technology with new ideas and opportunities, whereas larger teams have tended to develop existing ones. Work from larger teams builds on morerecent and popular developments, and attention to their work comes
immediately. By contrast, contributions by smaller teams search more deeply into the past, are viewed as disruptive to science and technology and succeed further into the future—if at all. Observed differences between small and large teams are magnified for higherimpact work, with small teams known for disruptive work and large teams for developing work. Differences in topic and research design
account for a small part of the relationship between team size and disruption; most of the effect occurs at the level of the individual, as people move between smaller and larger teams. These results demonstrate that both small and large teams are essential to a flourishing ecology of science and technology, and suggest that, to achieve this, science policies should aim to support a diversity of team sizes.</p>
</blockquote>
<p><br><br></p>
</div>
<div id="算法对比" class="section level2">
<h2>算法对比</h2>
<p>我没阅读两篇论文，仅就颠覆性与否的计算方法和图例，感觉算法实现差不多。</p>
<div class="figure">
<img src="img/cdindex-managent_science_2017.png" alt="" />
<p class="caption">上图为2017年Management Science的插图</p>
</div>
<p><br></p>
<div class="figure">
<img src="img/disruption_nature_2019.png" alt="" />
<p class="caption">上图为2019年Nature的插图</p>
</div>
<p><br><br></p>
</div>
<div id="代码数据" class="section level2">
<h2>代码数据</h2>
<p>下面分别为Management2017和Nature2019的主页，均含数据和代码。</p>
<p><a href="http://russellfunk.org/cdindex/"><img src="img/cdindex-homepage.png" /></a></p>
<p><br></p>
<p><a href="https://lingfeiwu.github.io/smallTeams/"><img src="img/nature2019-disrupt-homepage.png" /></a></p>
<p><br><br></p>
</div>
<div id="算法实现" class="section level2">
<h2>算法实现</h2>
<p>按照时间优先原则，本文就只分享Management2017论文作者Funk, Russell开源了cdindex库 (开发语言C和Python) ，安装</p>
<p><br></p>
<pre><code>pip3 install cdindex</code></pre>
<p>将Management2017 cdindex算法图 标注为如下图， 下图中左右两个网络节点是相同的，只需构造一套节点，两套边数据即可完成实验。</p>
<p><img src="img/cdindex-managent_science_2017_demo.png" /></p>
<p><br></p>
<p>我们就直接上代码</p>
<pre class="python"><code>import cdindex
import datetime

#节点，理解为专利号或者论文doi号；同时节点有先后时间属性
vertices = [{&quot;name&quot;: &quot;x1&quot;, &quot;time&quot;: datetime.datetime(1990, 1, 1)},
           {&quot;name&quot;: &quot;x2&quot;, &quot;time&quot;: datetime.datetime(1990, 1, 1)},
           {&quot;name&quot;: &quot;x3&quot;, &quot;time&quot;: datetime.datetime(1990, 1, 1)},
           {&quot;name&quot;: &quot;x4&quot;, &quot;time&quot;: datetime.datetime(1990, 1, 1)},
        
           {&quot;name&quot;: &quot;y&quot;, &quot;time&quot;: datetime.datetime(1991, 1, 1)},
          
           {&quot;name&quot;: &quot;z1&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)},
           {&quot;name&quot;: &quot;z2&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)},
           {&quot;name&quot;: &quot;z3&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)},
           {&quot;name&quot;: &quot;z4&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)},
           {&quot;name&quot;: &quot;z5&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)},
           {&quot;name&quot;: &quot;z6&quot;, &quot;time&quot;: datetime.datetime(1995, 1, 1)}]
           
    
#edges_1边关系
#edges_1中的y为颠覆型
edges_1 = [{&quot;source&quot;: &quot;z1&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z2&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z3&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z4&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z5&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z6&quot;, &quot;target&quot;: &quot;y&quot;},
           
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x1&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x2&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x3&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x4&quot;}]


#edges_2边关系 
#edges_2中的y为巩固型
edges_2 = [{&quot;source&quot;: &quot;z1&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z2&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z3&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z4&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z5&quot;, &quot;target&quot;: &quot;y&quot;},
           {&quot;source&quot;: &quot;z6&quot;, &quot;target&quot;: &quot;y&quot;},
           
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x1&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x2&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x3&quot;},
           {&quot;source&quot;: &quot;y&quot;, &quot;target&quot;: &quot;x4&quot;},
          
          {&quot;source&quot;: &quot;z1&quot;, &quot;target&quot;: &quot;x1&quot;},
          {&quot;source&quot;: &quot;z2&quot;, &quot;target&quot;: &quot;x1&quot;},
          {&quot;source&quot;: &quot;z3&quot;, &quot;target&quot;: &quot;x2&quot;},
           
          {&quot;source&quot;: &quot;z4&quot;, &quot;target&quot;: &quot;x3&quot;},
          {&quot;source&quot;: &quot;z5&quot;, &quot;target&quot;: &quot;x3&quot;},
          {&quot;source&quot;: &quot;z5&quot;, &quot;target&quot;: &quot;x4&quot;},
          {&quot;source&quot;: &quot;z6&quot;, &quot;target&quot;: &quot;x4&quot;}]



# 构建两个网络
graph1 = cdindex.Graph() #颠覆型
graph2 = cdindex.Graph() #发展型

# 添加节点
for vertex in vertices:
    graph1.add_vertex(vertex[&quot;name&quot;], cdindex.timestamp_from_datetime(vertex[&quot;time&quot;]))
    graph2.add_vertex(vertex[&quot;name&quot;], cdindex.timestamp_from_datetime(vertex[&quot;time&quot;]))

# 添加引用关系
for edge in edges_1:
    graph1.add_edge(edge[&quot;source&quot;], edge[&quot;target&quot;])
for edge in edges_2:
    graph2.add_edge(edge[&quot;source&quot;], edge[&quot;target&quot;])
    
    
#y研究发布后1825天内，引用y的论文(专利)列入网络。
t_delta = int(datetime.timedelta(days=1825).total_seconds())

#计算cdindex得分
score1 = graph1.cdindex(&quot;y&quot;, t_delta)
score2 = graph2.cdindex(&quot;y&quot;, t_delta)

print(&#39;左侧-网络中的y节点的cdinex得分: {}, 节点y 为颠覆性创新&#39;.format(score1))</code></pre>
<pre><code>## 左侧-网络中的y节点的cdinex得分: 1.0, 节点y 为颠覆性创新</code></pre>
<p><br></p>
<pre class="python"><code>print(&#39;右侧-网络中的y节点的cdinex得分: {}, 节点y 为发展性创新&#39;.format(score2))</code></pre>
<pre><code>## 右侧-网络中的y节点的cdinex得分: -1.0, 节点y 为发展性创新</code></pre>
<p><br><br></p>
</div>
<div id="cdindex" class="section level2">
<h2>cdindex</h2>
<p>对比Python的结果，与论文计算过程，完全一致。cdindex内部实现我不太熟悉，如果想了解cdindex内部实现，可前往 <a href="https://github.com/russellfunk/cdindex" class="uri">https://github.com/russellfunk/cdindex</a> 阅读cdindex库的源码。
<img src="img/cdindex-managent_science_2017.png" /></p>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>karateclub库 | 计算社交网络中节点的向量</title>
      <link>https://textdata.cn/blog/karateclub_tutorial/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/karateclub_tutorial/</guid>
      <description>使用karateclub计算社交网络中节点的向量，有了节点的向量，就可以基于向量思维比较节点异同</description>
      <content:encoded><![CDATA[<p><a href="https://karateclub.readthedocs.io/en/latest">karateclub</a>是小规模图挖掘研究的一把瑞士军刀， 可以对图形结构化数据进行无监督学习。</p>
<ul>
<li>首先，可以计算出节点、图的特征向量</li>
<li>其次，它包括多种重叠和非重叠的社区发现方法。</li>
</ul>
<br>
<h2 id="代码下载">代码下载</h2>
<p><a href="karateclub_example_code.zip">click to download</a></p>
<br>
<h2 id="数据格式">数据格式</h2>
<p>karateclub假设用户提供的用于<strong>节点嵌入</strong>和<strong>社区检测</strong>的 NetworkX 图具有以下重要属性：</p>
<ul>
<li>节点用整数索引</li>
<li>节点索引从零开始，索引是连续的</li>
</ul>
<p><strong>节点的属性矩阵</strong>可以提供为 scipy sparse 和 numpy 数组。返回的社区成员字典和嵌入矩阵使用相同的数字连续索引。</p>
<br>
<h2 id="安装">安装</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">pip3</span> <span class="n">install</span> <span class="n">karateclub</span>
</code></pre></div><br>
<h2 id="准备数据">准备数据</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;karate_club_graph.csv&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">())</span>

<span class="nb">print</span><span class="p">()</span>

<span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;tgt&#39;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

</code></pre></div><p>Run</p>
<pre><code>Index(['src', 'tgt'], dtype='object')

|    |   src |   tgt |
|---:|------:|------:|
|  0 |     0 |     1 |
|  1 |     0 |     2 |
|  2 |     0 |     3 |
|  3 |     0 |     4 |
|  4 |     0 |     5 |

[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 10), (0, 11), (0, 12), (0, 13), (0, 17), (0, 19), (0, 21), (0, 31), (1, 2), (1, 3), (1, 7), (1, 13), (1, 17), (1, 19), (1, 21), (1, 30), (2, 3), (2, 7), (2, 8), (2, 9), (2, 13), (2, 27), (2, 28), (2, 32), (3, 7), (3, 12), (3, 13), (4, 6), (4, 10), (5, 6), (5, 10), (5, 16), (6, 16), (8, 30), (8, 32), (8, 33), (9, 33), (13, 33), (14, 32), (14, 33), (15, 32), (15, 33), (18, 32), (18, 33), (19, 33), (20, 32), (20, 33), (22, 32), (22, 33), (23, 25), (23, 27), (23, 29), (23, 32), (23, 33), (24, 25), (24, 27), (24, 31), (25, 31), (26, 29), (26, 33), (27, 33), (28, 31), (28, 33), (29, 32), (29, 33), (30, 32), (30, 33), (31, 32), (31, 33), (32, 33)]
</code></pre>
<br>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</code></pre></div><p>Run</p>
<p>​ <br>
<img loading="lazy" src="output_4_0.png" alt="png"  />

​</p>
<br>
<h2 id="社区发现">社区发现</h2>
<p>现在让我们使用LabelPropagation算法来发现网络中的社区结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">karateclub</span> <span class="kn">import</span> <span class="n">LabelPropagation</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">LabelPropagation</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="n">cluster_membership</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_memberships</span><span class="p">()</span>
<span class="n">cluster_membership</span>
</code></pre></div><p>Run</p>
<pre><code>{23: 8,
 33: 8,
 5: 10,
 7: 1,
 28: 31,
 4: 10,
 3: 1,
 31: 31,
 20: 8,
 19: 1,
 6: 10,
 32: 8,
 29: 8,
 9: 1,
 14: 8,
 2: 1,
 0: 1,
 17: 1,
 25: 31,
 22: 8,
 11: 1,
 13: 1,
 1: 1,
 24: 31,
 15: 8,
 18: 8,
 26: 8,
 27: 8,
 16: 10,
 12: 1,
 30: 8,
 21: 1,
 8: 8,
 10: 10}
</code></pre>
<p>在有34个节点的图中，发现了4个社区，分别是1、8、10、31。</p>
<br>
<h2 id="node-embeddings">Node embeddings</h2>
<p>计算节点的向量。​使用 Diff2vec 拟合数据的节点嵌入(向量)，具有少量维度、每个源节点的扩散和短欧拉游走。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">karateclub</span> <span class="kn">import</span> <span class="n">Diff2Vec</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Diff2Vec</span><span class="p">(</span><span class="n">diffusion_number</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                 <span class="n">diffusion_cover</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> 
                 <span class="n">dimensions</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_embedding</span><span class="p">()</span>
<span class="n">X</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div><p>Run</p>
<pre><code>(34, 5)
</code></pre>
<br>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">X</span>
</code></pre></div><p>Run</p>
<pre><code>array([[ 1.3687179 , -0.33502993, -0.3294797 ,  0.40154558,  1.0270709 ],
       [ 0.88167036, -0.3201618 , -0.34293872,  0.41519755,  0.71964073],
       [ 0.8756805 , -0.21934716, -0.33261183,  0.33785722,  0.51631075],
       [ 0.9768452 , -0.39260587, -0.39460638,  0.28851682,  0.8665034 ],
       [ 0.4809215 , -0.28729865, -0.19276802,  0.22588767,  0.07305563],
       [ 0.5580538 , -0.28137547, -0.1947159 ,  0.23712516,  0.49257705],
       [ 0.23477663,  0.04262228,  0.07154325,  0.02909669,  0.33999097],
       [ 1.1882199 , -0.21742308, -0.26985615,  0.44171503,  0.6679048 ],
       [ 1.0287609 , -0.27409104, -0.04119629,  0.30143994,  0.704676  ],
       [ 0.5700088 , -0.26341844,  0.01560158, -0.08039217,  0.41796318],
       [ 0.5753763 , -0.2242508 , -0.1795436 ,  0.0705331 ,  0.46571913],
       [ 0.46763912, -0.17108741, -0.22459361,  0.03058788,  0.05998428],
       [ 0.5500626 , -0.12745889, -0.28661036,  0.16889155,  0.48200938],
       [ 0.6217582 , -0.10251168, -0.0713837 ,  0.13550574,  0.60422456],
       [ 0.9797377 , -0.46282482, -0.09380057,  0.2749968 ,  0.7020155 ],
       [ 0.38830167, -0.30841848, -0.20950563, -0.02130592,  0.0836651 ],
       [ 0.57225037, -0.04150235, -0.1246101 ,  0.06918757,  0.23083903],
       [ 0.6431406 , -0.04898892, -0.05708801,  0.1311793 ,  0.46377632],
       [ 0.541667  , -0.16031542, -0.33119023,  0.10385639,  0.39525154],
       [ 0.65543544, -0.27534947, -0.28757   ,  0.2080029 ,  0.5288213 ],
       [ 0.46381798, -0.07729273, -0.09209982,  0.11292508,  0.36836028],
       [ 0.53826964, -0.09915172, -0.09243581,  0.15036733,  0.5449071 ],
       [ 0.31599265, -0.22078821, -0.02872767,  0.07436654,  0.28573534],
       [ 1.0706906 , -0.27783617, -0.16653039,  0.2631594 ,  0.6408689 ],
       [ 0.67875004, -0.34441757, -0.10262538,  0.2588695 ,  0.38405937],
       [ 0.41786563, -0.10344986, -0.19508548,  0.19657765,  0.22006002],
       [ 0.7855942 , -0.27200857,  0.02204541,  0.09168041,  0.42220354],
       [ 0.7773458 , -0.11727296, -0.24145149,  0.04537854,  0.5737133 ],
       [ 0.75732976, -0.314953  , -0.15383345,  0.02065313,  0.51843405],
       [ 0.7226543 , -0.31919608, -0.18878649,  0.15413427,  0.42012522],
       [ 0.43411565, -0.17342259, -0.28042233,  0.26853496,  0.49947587],
       [ 1.1565564 , -0.36802933, -0.12613232,  0.32381424,  0.75113887],
       [ 1.1192797 , -0.162529  , -0.17195942,  0.39265418,  0.83656436],
       [ 1.2231556 , -0.5336606 , -0.14015286,  0.14054438,  0.5695296 ]],
      dtype=float32)
</code></pre>
<p><br><br></p>
<div style="text-align: center;">
<figure >
    <a href="https://textdata.cn/blog/management_python_course/">
        <img src="/images/bg/management_data_mining_with_python_course2.png" width="100%" />
    </a>
    <figcaption><small><i>点击了解课程详情</i></small></figcaption>
</figure>
</div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

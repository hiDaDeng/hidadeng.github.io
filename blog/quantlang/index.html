<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>量化历史语言学-贝叶斯语言谱系分析 | 大邓和他的PYTHON</title>
<meta name="keywords" content="学术应用, 文本分析" />
<meta name="description" content="量化历史语言学，尤其是贝叶斯语言谱系分析的前世今生，以及可能的未来">
<meta name="author" content="小云哥哥">
<link rel="canonical" href="/blog/quantlang/" />
<meta name="baidu-site-verification" content="code-xTk1LSyjvt" />
<meta name="360-site-verification" content="dc00b42cd1d4e0fcaa5edfd27394f9cd" />
<meta name="sogou-site-verification" content="3HDeo612Pl" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="量化历史语言学-贝叶斯语言谱系分析" />
<meta property="og:description" content="量化历史语言学，尤其是贝叶斯语言谱系分析的前世今生，以及可能的未来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/blog/quantlang/" />
<meta property="og:image" content="/images/blog/quant_Lang.png" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-01-01T20:43:10&#43;06:00" />
<meta property="article:modified_time" content="2022-01-01T20:43:10&#43;06:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="/images/blog/quant_Lang.png" />
<meta name="twitter:title" content="量化历史语言学-贝叶斯语言谱系分析"/>
<meta name="twitter:description" content="量化历史语言学，尤其是贝叶斯语言谱系分析的前世今生，以及可能的未来"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "/blog/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "量化历史语言学-贝叶斯语言谱系分析",
      "item": "/blog/quantlang/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "量化历史语言学-贝叶斯语言谱系分析",
  "name": "量化历史语言学-贝叶斯语言谱系分析",
  "description": "量化历史语言学，尤其是贝叶斯语言谱系分析的前世今生，以及可能的未来",
  "keywords": [
    "学术应用", "文本分析"
  ],
  "articleBody": " 点击上方图片购买课程    Author:小云哥哥\nSrc: https://zhuanlan.zhihu.com/p/386454664\n 历史语言学家有两个基本任务。第一个任务是追溯相关语言的源头——所谓的“原始语言”，说得通俗一点就是推测一下祖先们是怎么说话的。但其实除非有时光机器，否则我们不可能知道祖先的发音，构拟原始语言的最终目的是使用一个自洽的系统去解释现代亲属语言的差异。这个任务是技术活儿，需要硬功夫，语言学家必须对这些语言的各方面都了如指掌，通过多年的时间真正理解这些语言的运作（尤其是音系和形态），而不是一上来就开始尬比较。第二任务是第一个任务的衍生产品。当我们能够解释亲属语言的差异以后，我们自然而然会发现有的语言差异较小，有的语言差异较大，我们会希望知道每种差异发生的时间顺序，从而推断出亲属语言是因循什么轨迹从原始语言中分化出来的。这就是语言的谱系。\n虽然传统的历史语言学取得了非常大的成功，但是语言学家毕竟是人，他们用人力研究为数众多的语言、处理浩如烟海的语料，总会出现这样那样的问题。比如说我们会在不少著作中看到语言学家前后标准不一致，或者分析过程描述不清晰透明等现象。有时候这些问题并不是有意为之，而是因为人确实无法预估那么多的事情，出错在所难免。\n于是，一部分语言学家开始认识到，我们需要一个机器协助的、量化的转变。人的大脑爱耍小聪明，更擅长处理复杂而特殊的个案，而机器更像一个奴隶，可以帮人类用统一的方法处理繁多和重复的工作。那么，历史语言学家的两个任务，机器可以协助我们解决哪一个呢？原始语言的构拟还是语言的谱系？\n事实上，这两个任务都需要很多的小聪明。如果原始语言的构拟是简单的音位比较，那么机器也许可以很快做出来。但实际操作上要比这个绕很多的弯儿，需要语言学家综合知识的灵活运用。比如索绪尔的喉音理论，就需要对梵语动词变位的深入理解，从而比较不同变位模式的内在一致，并且对音变的类型学有融会贯通的了解。这一切的运作，可能在索绪尔的脑子里一秒钟就能形成，而机器则不可能在短时间内完成喉音的构拟。我们引入机器是为了提高效率，而不是降低效率。因此，语言学家把目光转向了第二个任务，语言的谱系。历史语言学确定谱系的唯一标准是共同创新，但辨认共同创新实际上也需要深厚的研究功底，机器很难按照人类的方式分析。一个比较可行的办法是偏离历史语言学的原则，使用统计学的方式，构造出在统计学意义上最可能的谱系。\n在这篇文章中，我就用流水账的方式梳理一下机器协助的语言谱系分析的相关历史，尤其专注于贝叶斯谱系分析。因为是流水账，所以不会分小节，我也会省去所有赶客的公式和理论描述。\n语言谱系分析 较早使用统计学处理语言谱系的研究可以追溯到十九世纪前叶。不过现代的尝试最值得提的是二十世纪二十年代开始的一系列操作。波兰人类学家Czekanowski[1]在1928年收集了二十多个音系、形态和词汇上的特点，研究了包括立陶宛语、古教会斯拉夫语、哥特语、古爱尔兰语、拉丁语、希腊语、吠陀梵语、阿维斯陀语和亚美尼亚语相互之间的关系。他们得出的结果其中一个错误是认为哥特语与波罗地-斯拉夫语更为接近，而不是意大利-凯尔特语。1937年，加州大学的Kroeber和Chrétien[2]在前人的基础上，添加了新的数据（主要是特征性的音变和形态变化方面的数据），使参与比较的特征达到了74个。下图是Kroeber and Chrétien (1937)的统计分析\n Kroeber和Chrétien就是通过判断每一个特征是否在各种语言中出现，列出矩阵计算出各语言的相似度。他们的结果，至少从这九种语言来看，基本上与历史语言学的结果相符。但由于数据本身的局限性，他们的方法并没有被大规模地使用，并且遭到了一些批评。我不知道他们的计算是否用了机器，但是从他们并不复杂的公式来看，可能是笔算的。\n虽然这些早期的尝试寿命并不长，但是也为量化历史语言学定下了统计学的基调，尽管在数据选取上，名义上是使用了历史语言学的结论，但是并没有使用历史语言学的分类标准，而是把这些结论转化成可以用于统计学的数据。这也是从这以后，直至现在将尽一个世纪的趋势。\n La linguistique est la science statistique type ; les statisticiens le savent bien ; la plupart des linguistes l’ignorent encore. (Guiraud 1959: 15[3]) 语言学就是典型的统计科学；统计学家心里很清楚，大部分语言学家却不知道。\n \n基于词汇的语言谱系分析 1950年代，有一个长得有点喜感的中年男人，叫Morris Swadesh。他是一个美国的语言学家。身为一个历史语言学家，他并不把关注的重点放在音系和形态的变化上，而是更专注于词汇。词汇相对于音系和形态，显然是更容易操作的东西，毕竟它们就像拼好的积木，能让人一眼就辨认出来。Morris Swadesh (1909-1967)\n Swadesh认为不同语言中词汇的重合度很可能与语系的演化有关。这点很符合我们的直觉，基因关系较远的语言中，非同源的词汇理应越多。而且，他还假设词汇系统是按一定的速率变化的，我们只要以这个速率为基础，然后比较亲属语言的同源词的多寡，就能得到语言的谱系，同时我们还可以算出亲属语言的分裂时间。Swadesh (1950)[4]认为词汇的变化速率是每过1000年，一种语言想对于原本形态的同源词就会降低到原来的85%。后来这个百分比又被改为81%。 这个数字大概是基于古英语和现代英语的词汇变化确定的。\n核心词汇 我们不可能穷尽所有的词汇，所以就需要选取一些具有代表性的词汇来简化我们的研究。Swadesh整理出一份100词的词表，现在我们称为“核心词汇”或者“基本词汇”，包括身体部位、数字、颜色、基本动作等类别，这些词汇被认为是最不容易被借用的，有较大的概率是本土词汇。\n语言断代学（词汇统计学） 这么一来，如果我们发现两种亲属语言在核心词汇表上有81%的同源词，那么我们就可以认为这两种语言的分化时间是1000年。如果它们有81%×81%=65.61%的同源词，那么它们的分化时间就是2000年。这个方法我们称为Glottochronology，汉语称作“语言断代学”，它也是“词汇统计学”（lexicostatistics）的最主要方法之一。\n为了让故事更连续，我在这里删除了其它的研究方法，比如计算词汇间Levenshtein距离，有关这方面的内容，可以看这个回答。\n总而言之，从Swadesh开始，量化历史语言学基本上就在词汇之间徘徊，人们开始想尽办法从词汇中找到语言发展的轨迹。当然， 也有从音系/形态上考虑的（Ringe et al 2002）[5]，还有从类型学上考虑的（Dunn et al 2008）[6]，但始终无法摆脱或者撼动以词汇为基础的大趋势。\n语言断代学虽然在语言谱系分析的量化上取得了较大的进展，但最终仍被认为是失败的方法。这是因为它强制规定词汇有着固定的变化速率。这一基本假设从直觉上就不符合语言的发展历程，而且没有靠谱的研究去证明，反而很容易被证伪。比如说，我们使用语言年代学的模型，我们会得到格鲁吉亚语和明格列尔语的分化年代距今约1000年左右。但实际上，它们两个的分化年代要远早于公元四到五世纪（Bergsland and Vogt 1962）[7]。Swadesh本人也觉得这个方法有问题。所以逐渐人们也就不再使用语言年代学了。\n语言断代学最大的贡献不在于它得出的结论有多正确，而是让人们看到为语言分化断代的希望，通过语言的年代来研究人类史前史成为了可能，历史语言学不再是自娱自乐地谈论古人怎么说话，而一跃成为了人类历史研究中最重要的学科之一。\n比如说，Gray and Jordan (2000)[8]使用简约分析（parsimony analysis）计算出南岛语的谱系，测试了有关南岛语系起源的两个假说，“快车假说（express-train）”和“岛屿纠缠假说（entangled bank）”。他们发现快车假说与南岛语谱系树惊人吻合，从而确认了南岛语是从台湾省起源，扩散到南部各个岛屿的。\n因为有了成功的希望，所以尽管有很多语言学家对语言的断代嗤之以鼻，另一部分语言学家仍旧在探索着新的道路。我们在这里将跳过一些不太受欢迎的研究方法，比如Ringe et al (2002)和Nakhleh et al (2005)[9]的“完全谱系”（perfect phylogenies）。他们跟二十世纪二三十年代的那帮人类似，使用了音系和形态方面的语料来计算，当然他们的统计学方法要先进得多。只不过，他们处理语料的方式跟前人一样，基本上就是看哪一些特征在哪一些语言中存在，并没有具体到确切的实例。\n语言变化的时钟-宽松时钟 谱系分析始终只是历史语言学家的其中一个任务，更多的历史语言学家喜欢智力游戏，在构拟上下的功夫比较多，对于机器处理的谱系分析的热情没那么高。正在这时，那一边厢，生物学家们正在努力地发展更有效的断代方法。美国亚利桑那大学的演化生物学家Michael Sanderson就是其中一个代表人物。他从1997到2002发表了一系列的论文[10][11]，研究了一些已知的谱系树分支的年龄，认为DNA序列的发展确实是有既定的速率，这个速率是它们内在的“时钟”决定的，在不同的分支中，时钟走动的快慢是有区别的。如果我们把这个思想代入到语言学中，我们就知道，按照Swadesh的语言年代学的方法，词汇的发展被认为有统一的“时钟”，或者叫“分子时钟”（molecular clock），我们称为“严格时钟”（strict clock），而分子生物学的最新假设则是引入了“宽松时钟”（relaxed clock），换成语言学，则是认为词汇在不同语支的替换速率并不统一，而是各有各的速率。顺便一提，Swadesh的语言年代学比分子生物学中的“分子时钟”的提出（Zuckerkandl and Pauling 1965）[12]要早十年左右，但是生物学家在接受新鲜事物和创新方面要比语言学家快得多。在贝叶斯谱系分析中，Thorne et al (1998)[13]和Drummond et al (2006)[14]等人都对严格时钟的框架进行了批评和测试，并发现宽松时钟确实可以更好地模拟真实的演化过程。\n历史语言学最终还是再次向生物学靠拢了。2003年，Gray and Atkinson (2003)[15]在Nature上发表了一篇文章，他们使用了贝叶斯谱系分析计算出了印欧语的谱系树，并如同之前测试南岛民族的演化历程一样，这次他们也用谱系树测试了印欧语起源的两种假说，并表示语言的谱系支持原始印欧人是安纳托利亚的农民这一种看法。下图是Gray and Atkinson (2003)的印欧语谱系树\n 谱系分析算法 那么，语言的贝叶斯谱系分析究竟是怎么进行的呢？就像我们之前说的，词汇仍旧是基础。我们选取一个核心词汇表，然后把词汇表中的词汇翻译成我们需要解决的诸语言。当然，这一切都是建立在我们有合理理由怀疑这些语言是同属一个语系的前提下，否则我们得到的结果就没有意义。把词汇翻译成各种语言以后，我们就开始辨别同源词。我们把每一个义项下的同源词找出来，并把它们配成对儿。下图是词源词典编辑工具Edictor界面下的同源词辨认\n 同一个义项下，不同的语言可能呈现不同的词汇。比如汉语中，表示“EAT”这个义项的词汇在粤语和闽南语中都是来自“食”的同源词（粤语：si̍k，闽南语chia̍h），而普通话中则用“吃”来替代。那么单凭这一个词，我们用人脑都可以算出来，粤语和闽南语应该归在一个分支下，而普通话则应该属于另一个分支。\n我们就这样把数十甚至上百种语言的同源词都标记出来，并且把它们转化为机器可读的形式。那么什么样的形式机器才可读呢？机器是不会管你每个词是怎么发音的，它只想知道某两个词是不是同源词。所以你只需要告诉它哪些词是同源词，哪些不是，就可以了。如果两个词是同源词，那么就标记一个“1”，如果不是就标记一个“0”。所以你就要做一个像下图一样的东西，全是0和1，咱们看不懂，但是机器很容易看懂：\n 看到这里，大家就明白了。贝叶斯谱系分析的数据是“同源关系”，而不是同源词本身。我们把数据喂给电脑，接下来就让电脑处理吧。\n马尔可夫链蒙特卡洛 很多传统语言学家诟病，电脑处理的这个部分不透明，像在黑盒里操作一样，不放心把一切交给程序。为了解除一部分疑虑，我在这里解释一下究竟机器是怎么算谱系树的，当然，为了不赶客，下文中不会出现深奥的东西。\n机器在得到我们这些充满0和1的数据后，会开始使用贝叶斯定理，计算出一棵谱系树的可能性。它会先随机生成一棵谱系树，这棵谱系树正确反映语言谱系的概率可想而知是非常低的，但机器就会根据输入的数据，把这个概率算出来，先记下。然后它就会改变原树的形状，生成一棵新的树，再计算出这棵树正确反映语言谱系的概率算出来，与前一棵树的概率比较。如果前一棵树的概率比较小，那么我们就保留新的这棵树。如果前一棵树的概率较大，那么说明新树比旧树还要差，因此我们就会计算前后两个概率的比值（用新的概率除以旧的概率），得到的就是接受这棵新树的概率。然后机器会一直生成新的树，一直重复着相同的比较和计算，一般我们会让机器重复上千万次的计算，从而保证生成的每一棵树的概率达到一个较为稳定的值。这个过程有个名字，叫马尔可夫链蒙特卡洛（Markov chain Monte Carlo，MCMC）。大家可以看以下这篇文章，对其中的数学做了详细介绍：\nhttps://zhuanlan.zhihu.com/p/420214359\n而今听雨：MCMC与贝叶斯推断简介：从入门到放弃111 赞同 · 16 评论文章\n共识树 计算完了上千万次的树以后，还要进行一个步骤。就是我们需要把前边那些低概率的树删掉一点，或者说“烧掉”（burn-in），这样我们就可以排除掉那些比较糟糕的树。最终留下的带有稳定较高概率的树的集合，就是机器为我们输出的结果。所以，我们在众多有关贝叶斯谱系分析论文中看到的树，都不是一棵树，而是成千上万棵具有相近概率的树相互妥协的结果，我们称为“共识树”（consensus tree）。\n机器计算出的每棵树的分支都有着不同的长度。这些长度跟每一个分支末端的语言年龄是成正比的。也就是说，单凭这些分支的长度，我们只能知道语言之间年龄的比值，而我们想知道的却是它们精确到年的真正年龄。这就需要我们找到一个参考点，或者一个称为prior的东西。Prior可以是对得出最佳谱系有利的任何参考数据，而针对语言谱系的年龄，最理想的prior就是语言被记录的时间。比如，我们知道书面藏语是1300多年前被记录的，那么我们就为书面藏语标记1300年的年龄。这样的信息越多，那么计算出来的年龄就会越准确。软件会结合分支的长度与我们给出的年龄信息，推算出其它语言的年龄。这样我们带有年龄的谱系树就产生了。\nDensitree 即便有了年龄，共识树还是共识树，我们不能把它看作一棵单一的谱系树，这也是许多人看这类文章的误区。其实，除了这棵共识树，机器还能给我们提供另一种树，叫做Densitree。Densitree可以把所有谱系树中冲突的部分可视化，让我们看到究竟哪里出了问题。Densitree看起来还是很美观的， 是无数线条的集合。下图中展示的Sagart et al (2019)[16]汉藏语谱系的Densitree，显示了计算过程中出现的非树形结构。一个完美的树形结构中，每一种语言应该只被一条线连接，但是我们看到在这棵树上，有不少语言被深浅不一的线群连接了，比如比较严重的有Chepang、Tshangla、Dulong等语言。存在这一类非树状信息的一大原因在于我们没有完全正确地辨认同源词，而是被部分表面现象骗了，把借词也算成同源词，也提醒我们重新审视我们的同源词判定。Sagart et al (2019)汉藏语谱系的Densitree\n 所以，我们除了看共识树以外，还要注意看densitree，densitree里有更多有用的信息。大部分人对于贝叶斯谱系分析，或者任何谱系分析的诟病都是基于最后的结论，极少注意到这些研究的数据结构和分析方法，甚至连结论都没有看全。因此，我呼吁大家除了看短短的正文，还要注意看文章的补充材料。\n贝叶斯谱系分析是不是语言学？ 语言学的贝叶斯谱系分析基本上就是如上述方式进行的，希望这样的描述足够通俗易懂。如果你们看懂了，你们可能会产生这一个疑问：究竟贝叶斯谱系分析跟传统历史语言学的结合有多紧密？这样子做出的语言谱系，究竟是不是语言学？\n首先，我们应该明确，至少在语言学上，谱系分析的作用不是告诉我们确切的谱系，而是给我们一个有关语言谱系的参考，是辅助历史语言学研究的工具，而不能代替历史语言学本身。比如说，我们推测出的汉藏语系的谱系可以帮我们确立今后汉藏语系历史语言学研究的大方向，因为我们知道了哪些语言更可能属于同一分支，那么我们就可以根据这些线索和思路有针对性的研究。\n贝叶斯语言谱系分析全过程中跟历史语言学有关的部分当然是前期的数据准备过程。这一过程需要历史语言学家判断同源词。如果研究对象是一个我们了解得比较深入的语系，比如印欧语系，我们判断同源词的标准当然是严格遵守历史语言学的原则的。但如果是像汉藏语系这种我们基本不了解的语系，判断同源词的时候很大程度上是靠猜测，有经验的语言学家比没有经验的一般人猜测的准确率自然会高出不少，但也不能完全保证准确。判断同源词的过程必须主要由人工处理。虽然现在也有不少判断同源词的工具和程序，但这些工具大部分基于词汇的相似性，但同源词、尤其是庞大语系下相距较远语言中的同源词往往不相似。比如拉丁语的duus和亚美尼亚语的erk是同源词，除非能把所有的音变告诉机器，否则机器是不可能把它们俩判断为同源词的。对于超级大的语系，判断同源词的工作可能长达数月，也需要好几个历史语言学家的商量与合作。做好同源词的数据后，我们就把一切复杂的计算交给电脑，等它算个几天，这一部分就脱离了传统语言学，进行纯粹统计学的计算了。\n在得到谱系树之后，我们还可以进行后续的历史语言学研究，并把历史语言学的结论与贝叶斯谱系树进行比较。比如说，Birchall et al (2016)[17]就为Chapacruan语系的语言做了一个贝叶斯谱系分析，并同时使用音变创新手动得出了另一个谱系树，并对两棵树进行了比较研究，发现贝叶斯谱系分析得出的结论与手动做出的谱系树还是比较吻合的。又比如，在Sagart et al (2019)的汉藏语谱系发表后，项目成员又发表了一些后续的历史语言学研究与其遥相呼应，比如Lai et al (2020)[18]对西夏语谱系地位的研究，以及Jacques et Pellard (2021)[19]对羌缅语的分析。\n虽然贝叶斯谱系分析的前前后后都少不了历史语言学的工作，但两者始终没有完全融合在一起，在整个研究中交集并不多，而是有着明显的分工。这一个弱点也经常被人们攻击。而且，贝叶斯谱系分析直到今天，都在使用语言学家们较为不喜欢的核心词汇作为基础，而词汇绝不能与生物学中的DNA序列相提并论，音系和形态才可以。\n那么为什么我们坚持使用词汇呢？我在这里谈两个原因。\n第一，词汇被认为可以涵盖历史语言学的大部分工作，并且容易操作。我们判断同源词的时候，自然要考虑到音变的规律性和对应关系，有时甚至要倒推形态，有时还要进行简单的构拟，这些工作都体现在同源词的判别中，因此我们选用词汇，并不是完全无视传统历史语言学，而是因为词汇的比较是传统历史语言学的“精华”。\n第二，词汇的替换是可以无限进行下去的，而且词汇替换的速率已经被证明可以用一定的模型去模拟。而音变则是比较有方向性的，有的音变一旦发生，可能就没办法回头了，比如p  f的音变很容易发生，而f  p的音变则极少发生。另外，音变可以很快，也可以很慢，它们究竟能不能模拟也是一大问题。\n因此，大部分语言学家在谱系分析时，都在如何更好地标记词汇上下功夫。以同源词关系为基础的谱系分析可以在较大的语系下取得成功，但如果我们要研究时间深度较浅的小分支，很可能就没那么得心应手了。\n比如我们要研究官话的谱系，大部分官话的核心词汇都差不多，词汇替换的现象比较少，那么我们喂给机器的数据库可能大部分都是“1”，这样我们可能会得到许多平行的分支，而不是一棵有结构的树。用贝叶斯谱系分析做出的官话谱系，可能不会比白一平（2006）[20]用最大简约法做出的官话谱系进步多少。再者，目前的贝叶斯分析也并非能对大语系完全掌控，比如说，Gray and Atkinson (2003)的印欧语谱系树最让人看不过眼的一点就是斯拉夫语的分类，大家可以自行上滑到他们的印欧语谱系树上，找找波兰语在哪里。\n再举一个极端的例子，假设两种语言互相不能通话（发生了重要的音变），但所有核心词汇都是同源词，没有发生词汇替换，那么机器将认为这两种语言是同一种语言。尽管这样极端的情况在现实世界中不会发生，尽管每一种研究方法都有它的不足之处，但我们应该事先考虑到突发状况的解决办法。这就是未来我们需要解决的问题。\n贝叶斯谱系分析在语言学上的应用已经差不多二十年了，但这二十年间，研究方法上的突破并不显著。人们当然知道这样的分析存在的问题，但是实际研究上，却很难去解决。比如在词汇替换中，有一种情况可能只有词汇的一部分被替换了，那么我们究竟是赋“1”呢，还是赋“0”呢？Hill and List (2017)[21]倒是提出了一个解决方案，他们开发了“部分同源词”（partial cognate）的标记方法，这种方法支持把一个词拆开，只标记同源的部分。如下图中，缅语支诸语言的“羽毛”一词，都可以分析称两个词素，我们可以把这两个词素拆开，分别标记同源关系。\n 部分同源词的标记实际上已经向基于形态的谱系分析迈进了一步，虽然它并没有真正触及到复杂的形态变化，但至少在尝试为合成词的问题寻求合理的解决方法。部分同源词的标记通过实验证明是可行的，但是目前并没有很多真枪实弹的研究成果发表出来。\n如果没有部分同源词的标记，贝叶斯谱系分析其实已经开始变得有点无聊，即便有了部分同源词标记，也并不能把它的有趣续命太久，毕竟这一步迈得也不大。当我们知道一个方法远没有达到理想的程度，但又不断原地打转时，我们就会自然而然地感到焦虑。\n未来的贝叶斯谱系分析的重点必然在于我们处理数据的方式，如何融入更多的历史语言学原则是我们需要思考的。在上文中，我们已经提到，目前声称把语言学和贝叶斯谱系结合在一起的研究无非就是分别用贝叶斯做一个，再用语言学做一个，然后再进行定性的比较。这种方法是绝不能让人满意的。我们需要更加无缝的衔接。\n另外，回归到1930年代或者Ringe et al (2002)和Nakhleh et al (2005)的“完全谱系”那种基于音系和形态特征的谱系分析似乎也是不可取的。因为这些研究对具体数据的处理完全不够，仅仅是从前人的作品里选出一部分可能对分类有用的特征进行计算，这中间仍会有许多不清晰的地方。\n最理想的情景是从语料入手，自然地融入同源词判定以及音系、形态上的创新，让机器根据各语言创新的情况来计算出谱系树。这样不仅仅能大大增加研究的客观性和透明性——单纯的同源词判定的主观因素占比非常严重，而使用创新为依据可以让读者更直接地找出潜在的问题，而且可以让谱系分析有更强大的理论背景。\n最后 恰好，昨天（2021年7月6日），我在我们所的部门会议上谈到了这个问题，Gray and Atkinson (2003)的作者之一，Russell Gray，也是我们的部门主任，也谈了他的想法。他非常愿意看到新的贝叶斯谱系的方案，不过他承认即便在印欧语的谱系研究中，完全融合语言各层面的数据也是极难做到的。我解释道我不是想完全放弃以词汇的同源关系为基础的谱系分析，而是希望能通过音系和形态，去检验词汇同源关系所无法得到的细节。我的预感是，如果我们融入了音系/形态的创新，得出的结果中，非树状信号会大大减少，并帮我们检查同源词判定究竟在哪里出现了问题。\n流水账就写到这里吧。我想大家在这篇流水账中看到的中心思想，是通过量化谱系分析的发展史，看到研究方法一步一步的变迁，以及它们遇到的困难和存在的问题。我们应该知道，评价这类研究的重点在于它们的方法，而不仅仅局限于结论——因为结论必然是有问题的，即便我们得到了一棵完美全对的谱系树，它仍旧是存在问题的，因为它并非完全基于历史语言学理论，而很大程度基于概率，它的完美只是概率问题（有时候太漂亮的结果，也是我们担心的来源之一）。只有对数据处理的方法不断地改进，才有可能把我们带向最真实的谱系分析。\n谱系分析是历史语言学研究中的一个强大的辅助，尤其是它自带断代的特征，可以让我们更好地追溯人类的历史。因此今后的历史语言学家对机器协助的谱系研究会更加上心，争取让既有的历史语言学理论与新兴的技术更加默契地配合。这也是我的愿望列表上的一项，在今后数年的研究中会作出各种各样的尝试。\n参考  Jan Czekanowski, Na Marginesie Recenzji P. K. Moszyiskiego o Ksigtce: Wstep do Historji Slowian. Lud, Series II, vol. VII (1928). Kroeber, A., \u0026 Chrétien, C. (1937). Quantitative Classification of Indo-European Languages. Language, 13(2), 83-103. doi:10.2307/408715 Guiraud, Pierre (1959), Problèmes et méthodes de la statistique linguistique, D. Reidel, Publishing Company, Dordrecht, Holland. Swadesh, M. (1950). Salish internal relationships. International Journal of American Linguistics, 16(4), 157-167. Ringe, D., Warnow, T., \u0026 Taylor, A. (2002). Indo‐European and computational cladistics. Transactions of the philological society, 100(1), 59-129. Dunn, M., Levinson, S. C., Lindström, E., Reesink, G., \u0026 Terrill, A. (2008). Structural phylogeny in historical linguistics: Methodological explorations applied in Island Melanesia. Language, 710-759. Bergsland, K., \u0026 Vogt, H. (1962). On the validity of glottochronology. Current anthropology, 3(2), 115-153. Gray, R. D., \u0026 Jordan, F. M. Language trees support the express-train sequence of Austronesian expansion, 2000. Nature, 405, 1052. Nakhleh, L., Ringe, D., \u0026 Warnow, T. (2005). Perfect phylogenetic networks: A new methodology for reconstructing the evolutionary history of natural languages. Language, 382-420. Sanderson, M. J. (1997). A nonparametric approach to estimating divergence times in the absence of rate constancy. Molecular biology and evolution, 14(12), 1218-1231. Sanderson, M. 2002 Estimating absolute rates of evo- lution and divergence times: a penalized likelihood approach. Mol. Biol. Evol. 19, 101–109. Zuckerkandl, E., \u0026 Pauling, L. (1965). Evolutionary divergence and convergence in proteins. In Evolving genes and proteins (pp. 97-166). Academic Press. Thorne, J. L., Kishino, H., \u0026 Painter, I. S. (1998). Estimating the rate of evolution of the rate of molecular evolution. Molecular biology and evolution, 15(12), 1647-1657. Drummond, A. J., Ho, S. Y. W., Phillips, M. J. \u0026 Rambaut, A. 2006 Relaxed phylogenies and dating with confidence. PLoS Biol. 4, e88. 699 – 710. (doi:10.1371/ journal.pbio.0040088) Gray, R. D., \u0026 Atkinson, Q. D. (2003). Language-tree divergence times support the Anatolian theory of Indo-European origin. Nature, 426(6965), 435-439. Sagart, L., Jacques, G., Lai, Y., Ryder, R. J., Thouzeau, V., Greenhill, S. J., \u0026 List, J. M. (2019). Dated language phylogenies shed light on the ancestry of Sino-Tibetan. Proceedings of the National Academy of Sciences, 116(21), 10317-10322. Birchall, J., Dunn, M., \u0026 Greenhill, S. J. (2016). A combined comparative and phylogenetic analysis of the Chapacuran language family. International Journal of American Linguistics, 82(3), 255-284. Lai, Yunfan., Gong, Xun., Gates, Jesse. P., \u0026 Jacques, Guillaume. (2020). Tangut as a West Gyalrongic language. Folia Linguistica Historica, 54(s41), 171-203. Jacques, G., \u0026 Pellard, T. (2021). Phylogenies based on lexical innovations refute the Rung hypothesis. Diachronica, 38(1), 1-24. Baxter, W. H. (2006). Mandarin dialect phylogeny. Cahiers de linguistique-Asie orientale, 35(1), 71-114. Hill, N. W., \u0026 List, J. M. (2017, September). Challenges of annotation and analysis in computer-assisted language comparison: A case study on Burmish languages. In Yearbook of the Poznan Linguistic Meeting (Vol. 3, No. 1, pp. 47-76). De Gruyter Open.  ",
  "wordCount" : "658",
  "inLanguage": "en",
  "image":"/images/blog/quant_Lang.png","datePublished": "2022-01-01T20:43:10+06:00",
  "dateModified": "2022-01-01T20:43:10+06:00",
  "author":{
    "@type": "Person",
    "name": "小云哥哥"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/blog/quantlang/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "大邓和他的PYTHON",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SFGQCREQ9X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SFGQCREQ9X');
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="大邓和他的PYTHON (Alt + H)" target="_blank">大邓和他的PYTHON</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/blog" title="博文" target="_blank">
                    <span>博文</span>
                </a>
            </li>
            <li>
                <a href="/search/" title="搜索" target="_blank">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="标签" target="_blank">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="mailto:thunderhit@qq.com" title="联系" target="_blank">
                    <span>联系</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
onload="renderMathInElement(document.body);"></script>


<article class="post-single">
  <header class="post-header">
    
    <div class="breadcrumbs"><a href="/" target="_blank">Home</a>&nbsp;»&nbsp;<a href="/blog/" target="_blank">Blogs</a></div>
    <h1 class="post-title">
      量化历史语言学-贝叶斯语言谱系分析
    </h1>
    <div class="post-meta"><span title='2022-01-01 20:43:10 +0600 +0600'>2022-01-01</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;小云哥哥

</div>

    <div>
      <br>
      <ul class="post-tags">
        <li><a href="/tags/%E5%AD%A6%E6%9C%AF%E5%BA%94%E7%94%A8/" target='_blank'>学术应用</a></li>
        <li><a href="/tags/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" target='_blank'>文本分析</a></li>
      </ul>
    </div>
  </header> 
<figure class="entry-cover"><a href="/images/blog/quant_Lang.png" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="/images/blog/quant_Lang.png" alt=""></a>
        
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%af%ad%e8%a8%80%e8%b0%b1%e7%b3%bb%e5%88%86%e6%9e%90" aria-label="语言谱系分析">语言谱系分析</a></li>
                    <li>
                        <a href="#%e5%9f%ba%e4%ba%8e%e8%af%8d%e6%b1%87%e7%9a%84%e8%af%ad%e8%a8%80%e8%b0%b1%e7%b3%bb%e5%88%86%e6%9e%90" aria-label="基于词汇的语言谱系分析">基于词汇的语言谱系分析</a><ul>
                            
                    <li>
                        <a href="#%e6%a0%b8%e5%bf%83%e8%af%8d%e6%b1%87" aria-label="核心词汇">核心词汇</a></li>
                    <li>
                        <a href="#%e8%af%ad%e8%a8%80%e6%96%ad%e4%bb%a3%e5%ad%a6%e8%af%8d%e6%b1%87%e7%bb%9f%e8%ae%a1%e5%ad%a6" aria-label="语言断代学（词汇统计学）">语言断代学（词汇统计学）</a></li>
                    <li>
                        <a href="#%e8%af%ad%e8%a8%80%e5%8f%98%e5%8c%96%e7%9a%84%e6%97%b6%e9%92%9f-%e5%ae%bd%e6%9d%be%e6%97%b6%e9%92%9f" aria-label="语言变化的时钟-宽松时钟">语言变化的时钟-宽松时钟</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%b0%b1%e7%b3%bb%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95" aria-label="谱系分析算法">谱系分析算法</a><ul>
                            
                    <li>
                        <a href="#%e9%a9%ac%e5%b0%94%e5%8f%af%e5%a4%ab%e9%93%be%e8%92%99%e7%89%b9%e5%8d%a1%e6%b4%9b" aria-label="马尔可夫链蒙特卡洛">马尔可夫链蒙特卡洛</a></li>
                    <li>
                        <a href="#%e5%85%b1%e8%af%86%e6%a0%91" aria-label="共识树">共识树</a></li>
                    <li>
                        <a href="#densitree" aria-label="Densitree">Densitree</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%b4%9d%e5%8f%b6%e6%96%af%e8%b0%b1%e7%b3%bb%e5%88%86%e6%9e%90%e6%98%af%e4%b8%8d%e6%98%af%e8%af%ad%e8%a8%80%e5%ad%a6" aria-label="贝叶斯谱系分析是不是语言学？">贝叶斯谱系分析是不是语言学？</a></li>
                    <li>
                        <a href="#%e6%9c%80%e5%90%8e" aria-label="最后">最后</a></li>
                    <li>
                        <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><div style="text-align: center;">
<figure >
    <a href="https://m.qlchat.com/wechat/page/channel-intro?channelId=2000015158133596">
        <img src="/images/bg/management_data_mining_with_python_course.png" width="90%" />
    </a>
    <figcaption><small><i>点击上方图片购买课程</i></small></figcaption>
</figure>
</div>
<br>
<blockquote>
<p>Author:小云哥哥</p>
<p>Src: <a href="https://zhuanlan.zhihu.com/p/386454664">https://zhuanlan.zhihu.com/p/386454664</a></p>
</blockquote>
<p>历史语言学家有两个基本任务。第一个任务是追溯相关语言的源头——所谓的“原始语言”，说得通俗一点就是推测一下祖先们是怎么说话的。但其实除非有时光机器，否则我们不可能知道祖先的发音，构拟原始语言的最终目的是使用一个自洽的系统去解释现代亲属语言的差异。这个任务是技术活儿，需要硬功夫，语言学家必须对这些语言的各方面都了如指掌，通过多年的时间真正理解这些语言的运作（尤其是音系和形态），而不是一上来就开始尬比较。第二任务是第一个任务的衍生产品。当我们能够解释亲属语言的差异以后，我们自然而然会发现有的语言差异较小，有的语言差异较大，我们会希望知道每种差异发生的时间顺序，从而推断出亲属语言是因循什么轨迹从原始语言中分化出来的。这就是语言的谱系。</p>
<p>虽然传统的历史语言学取得了非常大的成功，但是语言学家毕竟是人，他们用人力研究为数众多的语言、处理浩如烟海的语料，总会出现这样那样的问题。比如说我们会在不少著作中看到语言学家前后标准不一致，或者分析过程描述不清晰透明等现象。有时候这些问题并不是有意为之，而是因为人确实无法预估那么多的事情，出错在所难免。</p>
<p>于是，一部分语言学家开始认识到，我们需要一个机器协助的、量化的转变。人的大脑爱耍小聪明，更擅长处理复杂而特殊的个案，而机器更像一个奴隶，可以帮人类用统一的方法处理繁多和重复的工作。那么，历史语言学家的两个任务，机器可以协助我们解决哪一个呢？原始语言的构拟还是语言的谱系？</p>
<p>事实上，这两个任务都需要很多的小聪明。如果原始语言的构拟是简单的音位比较，那么机器也许可以很快做出来。但实际操作上要比这个绕很多的弯儿，需要语言学家综合知识的灵活运用。比如索绪尔的喉音理论，就需要对梵语动词变位的深入理解，从而比较不同变位模式的内在一致，并且对音变的类型学有融会贯通的了解。这一切的运作，可能在索绪尔的脑子里一秒钟就能形成，而机器则不可能在短时间内完成喉音的构拟。我们引入机器是为了提高效率，而不是降低效率。<strong>因此，语言学家把目光转向了第二个任务，语言的谱系</strong>。历史语言学确定谱系的唯一标准是共同创新，但辨认共同创新实际上也需要深厚的研究功底，机器很难按照人类的方式分析。一个比较可行的办法是偏离历史语言学的原则，使用统计学的方式，构造出在统计学意义上最可能的谱系。</p>
<p>在这篇文章中，我就用流水账的方式梳理一下机器协助的语言谱系分析的相关历史，尤其专注于贝叶斯谱系分析。因为是流水账，所以不会分小节，我也会省去所有赶客的公式和理论描述。</p>
<br>
<h2 id="语言谱系分析">语言谱系分析<a hidden class="anchor" aria-hidden="true" href="#语言谱系分析">#</a></h2>
<p>较早使用统计学处理语言谱系的研究可以追溯到十九世纪前叶。不过现代的尝试最值得提的是二十世纪二十年代开始的一系列操作。波兰人类学家Czekanowski[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_1">1]</a>在1928年收集了二十多个音系、形态和词汇上的特点，研究了包括立陶宛语、古教会斯拉夫语、哥特语、古爱尔兰语、拉丁语、希腊语、吠陀梵语、阿维斯陀语和亚美尼亚语相互之间的关系。他们得出的结果其中一个错误是认为哥特语与波罗地-斯拉夫语更为接近，而不是意大利-凯尔特语。1937年，加州大学的Kroeber和Chrétien[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_2">2]</a>在前人的基础上，添加了新的数据（主要是特征性的音变和形态变化方面的数据），使参与比较的特征达到了74个。下图是Kroeber and Chrétien (1937)的统计分析</p>

<figure >
    
        <img src="img/tab_occu.jpg" width="800" />
    
    
</figure>

<p>Kroeber和Chrétien就是通过判断每一个特征是否在各种语言中出现，列出矩阵计算出各语言的相似度。他们的结果，至少从这九种语言来看，基本上与历史语言学的结果相符。但由于数据本身的局限性，他们的方法并没有被大规模地使用，并且遭到了一些批评。我不知道他们的计算是否用了机器，但是从他们并不复杂的公式来看，可能是笔算的。</p>
<p>虽然这些早期的尝试寿命并不长，但是也为量化历史语言学定下了统计学的基调，尽管在数据选取上，名义上是使用了历史语言学的结论，但是并没有使用历史语言学的分类标准，而是把这些结论转化成可以用于统计学的数据。这也是从这以后，直至现在将尽一个世纪的趋势。</p>
<blockquote>
<p>La linguistique est la science statistique type ; les statisticiens le savent bien ; la plupart des linguistes l&rsquo;ignorent encore. (Guiraud 1959: 15[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_3">3]</a>)
语言学就是典型的统计科学；统计学家心里很清楚，大部分语言学家却不知道。</p>
</blockquote>
<p>&lt;比如&gt;</p>
<h2 id="基于词汇的语言谱系分析">基于词汇的语言谱系分析<a hidden class="anchor" aria-hidden="true" href="#基于词汇的语言谱系分析">#</a></h2>
<p>1950年代，有一个长得有点喜感的中年男人，叫Morris Swadesh。他是一个美国的语言学家。身为一个历史语言学家，他并不把关注的重点放在音系和形态的变化上，而是更专注于词汇。词汇相对于音系和形态，显然是更容易操作的东西，毕竟它们就像拼好的积木，能让人一眼就辨认出来。Morris Swadesh (1909-1967)</p>

<figure >
    
        <img src="img/Morris.jpg" width="800" />
    
    
</figure>

<p>Swadesh认为不同语言中词汇的重合度很可能与语系的演化有关。这点很符合我们的直觉，基因关系较远的语言中，非同源的词汇理应越多。而且，他还假设词汇系统是按一定的速率变化的，我们只要以这个速率为基础，然后比较亲属语言的同源词的多寡，就能得到语言的谱系，同时我们还可以算出亲属语言的分裂时间。<strong>Swadesh (1950)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_4">4]</a>认为词汇的变化速率是每过1000年，一种语言想对于原本形态的同源词就会降低到原来的85%。后来这个百分比又被改为81%。 这个数字大概是基于古英语和现代英语的词汇变化确定的</strong>。</p>
<h3 id="核心词汇">核心词汇<a hidden class="anchor" aria-hidden="true" href="#核心词汇">#</a></h3>
<p>我们不可能穷尽所有的词汇，所以就需要选取一些具有代表性的词汇来简化我们的研究。Swadesh整理出一份100词的词表，现在我们称为“<strong>核心词汇</strong>”或者“<strong>基本词汇</strong>”，包括身体部位、数字、颜色、基本动作等类别，这些词汇被认为是最不容易被借用的，有较大的概率是本土词汇。</p>
<h3 id="语言断代学词汇统计学">语言断代学（词汇统计学）<a hidden class="anchor" aria-hidden="true" href="#语言断代学词汇统计学">#</a></h3>
<p>这么一来，如果我们发现两种亲属语言在核心词汇表上有81%的同源词，那么我们就可以认为这两种语言的分化时间是1000年。如果它们有81%×81%=65.61%的同源词，那么它们的分化时间就是2000年。这个方法我们称为Glottochronology，汉语称作“<strong>语言断代学</strong>”，它也是“<strong>词汇统计学</strong>”（lexicostatistics）的最主要方法之一。</p>
<p>为了让故事更连续，我在这里删除了其它的研究方法，比如计算词汇间Levenshtein距离，有关这方面的内容，可以看<a href="https://www.zhihu.com/question/442752699/answer/1714008582">这个回答</a>。</p>
<p>总而言之，从Swadesh开始，量化历史语言学基本上就在词汇之间徘徊，人们开始想尽办法从词汇中找到语言发展的轨迹。当然， 也有从音系/形态上考虑的（Ringe et al 2002）[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_5">5]</a>，还有从类型学上考虑的（Dunn et al 2008）[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_6">6]</a>，但始终无法摆脱或者撼动以词汇为基础的大趋势。</p>
<p>语言断代学虽然在语言谱系分析的量化上取得了较大的进展，但最终仍被认为是失败的方法。这是因为它强制规定词汇有着固定的变化速率。这一基本假设从直觉上就不符合语言的发展历程，而且没有靠谱的研究去证明，反而很容易被证伪。比如说，我们使用语言年代学的模型，我们会得到格鲁吉亚语和明格列尔语的分化年代距今约1000年左右。但实际上，它们两个的分化年代要远早于公元四到五世纪（Bergsland and Vogt 1962）[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_7">7]</a>。Swadesh本人也觉得这个方法有问题。所以逐渐人们也就不再使用语言年代学了。</p>
<p>语言断代学最大的贡献不在于它得出的结论有多正确，而是让人们看到为语言分化断代的希望，通过语言的年代来研究人类史前史成为了可能，历史语言学不再是自娱自乐地谈论古人怎么说话，而一跃成为了人类历史研究中最重要的学科之一。</p>
<p>比如说，Gray and Jordan (2000)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_8">8]</a>使用简约分析（parsimony analysis）计算出南岛语的谱系，测试了有关南岛语系起源的两个假说，“快车假说（express-train）”和“岛屿纠缠假说（entangled bank）”。他们发现快车假说与南岛语谱系树惊人吻合，从而确认了南岛语是从台湾省起源，扩散到南部各个岛屿的。</p>
<p>因为有了成功的希望，所以尽管有很多语言学家对语言的断代嗤之以鼻，另一部分语言学家仍旧在探索着新的道路。我们在这里将跳过一些不太受欢迎的研究方法，比如Ringe et al (2002)和Nakhleh et al (2005)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_9">9]</a>的“完全谱系”（perfect phylogenies）。他们跟二十世纪二三十年代的那帮人类似，使用了音系和形态方面的语料来计算，当然他们的统计学方法要先进得多。只不过，他们处理语料的方式跟前人一样，基本上就是看哪一些特征在哪一些语言中存在，并没有具体到确切的实例。</p>
<h3 id="语言变化的时钟-宽松时钟">语言变化的时钟-宽松时钟<a hidden class="anchor" aria-hidden="true" href="#语言变化的时钟-宽松时钟">#</a></h3>
<p>谱系分析始终只是历史语言学家的其中一个任务，更多的历史语言学家喜欢智力游戏，在构拟上下的功夫比较多，对于机器处理的谱系分析的热情没那么高。正在这时，那一边厢，生物学家们正在努力地发展更有效的断代方法。美国亚利桑那大学的演化生物学家Michael Sanderson就是其中一个代表人物。他从1997到2002发表了一系列的论文[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_10">10]</a>[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_11">11]</a>，研究了一些已知的谱系树分支的年龄，认为DNA序列的发展确实是有既定的速率，这个速率是它们内在的“时钟”决定的，在不同的分支中，时钟走动的快慢是有区别的。如果我们把这个思想代入到语言学中，我们就知道，按照Swadesh的语言年代学的方法，词汇的发展被认为有统一的“时钟”，或者叫“分子时钟”（molecular clock），我们称为“严格时钟”（strict clock），而分子生物学的最新假设则是引入了“宽松时钟”（relaxed clock），换成语言学，则是认为词汇在不同语支的替换速率并不统一，而是各有各的速率。顺便一提，Swadesh的语言年代学比分子生物学中的“分子时钟”的提出（Zuckerkandl and Pauling 1965）[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_12">12]</a>要早十年左右，但是生物学家在接受新鲜事物和创新方面要比语言学家快得多。在贝叶斯谱系分析中，Thorne et al (1998)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_13">13]</a>和Drummond et al (2006)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_14">14]</a>等人都对严格时钟的框架进行了批评和测试，并发现宽松时钟确实可以更好地模拟真实的演化过程。</p>
<p>历史语言学最终还是再次向生物学靠拢了。2003年，Gray and Atkinson (2003)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_15">15]</a>在Nature上发表了一篇文章，他们使用了贝叶斯谱系分析计算出了印欧语的谱系树，并如同之前测试南岛民族的演化历程一样，这次他们也用谱系树测试了印欧语起源的两种假说，并表示语言的谱系支持原始印欧人是安纳托利亚的农民这一种看法。下图是Gray and Atkinson (2003)的印欧语谱系树</p>

<figure >
    
        <img src="img/Hcluster.jpg" width="800" />
    
    
</figure>

<br>
<h2 id="谱系分析算法">谱系分析算法<a hidden class="anchor" aria-hidden="true" href="#谱系分析算法">#</a></h2>
<p>那么，语言的贝叶斯谱系分析究竟是怎么进行的呢？就像我们之前说的，词汇仍旧是基础。我们选取一个核心词汇表，然后把词汇表中的词汇翻译成我们需要解决的诸语言。当然，这一切都是建立在我们有合理理由怀疑这些语言是同属一个语系的前提下，否则我们得到的结果就没有意义。把词汇翻译成各种语言以后，我们就开始辨别同源词。我们把每一个义项下的同源词找出来，并把它们配成对儿。下图是词源词典编辑工具Edictor界面下的同源词辨认</p>

<figure >
    
        <img src="img/alignLang.jpg" width="800" />
    
    
</figure>

<p>同一个义项下，不同的语言可能呈现不同的词汇。比如汉语中，表示“EAT”这个义项的词汇在粤语和闽南语中都是来自“食”的同源词（粤语：si̍k，闽南语chia̍h），而普通话中则用“吃”来替代。那么单凭这一个词，我们用人脑都可以算出来，粤语和闽南语应该归在一个分支下，而普通话则应该属于另一个分支。</p>
<p>我们就这样把数十甚至上百种语言的同源词都标记出来，并且把它们转化为机器可读的形式。那么什么样的形式机器才可读呢？机器是不会管你每个词是怎么发音的，它只想知道某两个词是不是同源词。所以你只需要告诉它哪些词是同源词，哪些不是，就可以了。如果两个词是同源词，那么就标记一个“1”，如果不是就标记一个“0”。所以你就要做一个像下图一样的东西，全是0和1，咱们看不懂，但是机器很容易看懂：</p>

<figure >
    
        <img src="img/binary.jpg" width="800" />
    
    
</figure>

<p>看到这里，大家就明白了。贝叶斯谱系分析的数据是“同源关系”，而不是同源词本身。我们把数据喂给电脑，接下来就让电脑处理吧。</p>
<h3 id="马尔可夫链蒙特卡洛">马尔可夫链蒙特卡洛<a hidden class="anchor" aria-hidden="true" href="#马尔可夫链蒙特卡洛">#</a></h3>
<p>很多传统语言学家诟病，电脑处理的这个部分不透明，像在黑盒里操作一样，不放心把一切交给程序。为了解除一部分疑虑，我在这里解释一下究竟机器是怎么算谱系树的，当然，为了不赶客，下文中不会出现深奥的东西。</p>
<p>机器在得到我们这些充满0和1的数据后，会开始使用贝叶斯定理，计算出一棵谱系树的可能性。它会先随机生成一棵谱系树，这棵谱系树正确反映语言谱系的概率可想而知是非常低的，但机器就会根据输入的数据，把这个概率算出来，先记下。然后它就会改变原树的形状，生成一棵新的树，再计算出这棵树正确反映语言谱系的概率算出来，与前一棵树的概率比较。如果前一棵树的概率比较小，那么我们就保留新的这棵树。如果前一棵树的概率较大，那么说明新树比旧树还要差，因此我们就会计算前后两个概率的比值（用新的概率除以旧的概率），得到的就是接受这棵新树的概率。然后机器会一直生成新的树，一直重复着相同的比较和计算，一般我们会让机器重复上千万次的计算，从而保证生成的每一棵树的概率达到一个较为稳定的值。这个过程有个名字，叫马尔可夫链蒙特卡洛（Markov chain Monte Carlo，MCMC）。大家可以看以下这篇文章，对其中的数学做了详细介绍：</p>
<p><a href="https://zhuanlan.zhihu.com/p/420214359">https://zhuanlan.zhihu.com/p/420214359</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/420214359">而今听雨：MCMC与贝叶斯推断简介：从入门到放弃111 赞同 · 16 评论文章</a></p>
<h3 id="共识树">共识树<a hidden class="anchor" aria-hidden="true" href="#共识树">#</a></h3>
<p>计算完了上千万次的树以后，还要进行一个步骤。就是我们需要把前边那些低概率的树删掉一点，或者说“烧掉”（burn-in），这样我们就可以排除掉那些比较糟糕的树。最终留下的带有稳定较高概率的树的集合，就是机器为我们输出的结果。所以，我们在众多有关贝叶斯谱系分析论文中看到的树，都不是一棵树，而是成千上万棵具有相近概率的树相互妥协的结果，我们称为“共识树”（consensus tree）。</p>
<p>机器计算出的每棵树的分支都有着不同的长度。这些长度跟每一个分支末端的语言年龄是成正比的。也就是说，单凭这些分支的长度，我们只能知道语言之间年龄的比值，而我们想知道的却是它们精确到年的真正年龄。这就需要我们找到一个参考点，或者一个称为prior的东西。Prior可以是对得出最佳谱系有利的任何参考数据，而针对语言谱系的年龄，最理想的prior就是语言被记录的时间。比如，我们知道书面藏语是1300多年前被记录的，那么我们就为书面藏语标记1300年的年龄。这样的信息越多，那么计算出来的年龄就会越准确。软件会结合分支的长度与我们给出的年龄信息，推算出其它语言的年龄。这样我们带有年龄的谱系树就产生了。</p>
<h3 id="densitree">Densitree<a hidden class="anchor" aria-hidden="true" href="#densitree">#</a></h3>
<p>即便有了年龄，共识树还是共识树，我们不能把它看作一棵单一的谱系树，这也是许多人看这类文章的误区。其实，除了这棵共识树，机器还能给我们提供另一种树，叫做Densitree。Densitree可以把所有谱系树中冲突的部分可视化，让我们看到究竟哪里出了问题。Densitree看起来还是很美观的， 是无数线条的集合。下图中展示的Sagart et al (2019)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_16">16]</a>汉藏语谱系的Densitree，显示了计算过程中出现的非树形结构。一个完美的树形结构中，每一种语言应该只被一条线连接，但是我们看到在这棵树上，有不少语言被深浅不一的线群连接了，比如比较严重的有Chepang、Tshangla、Dulong等语言。存在这一类非树状信息的一大原因在于我们没有完全正确地辨认同源词，而是被部分表面现象骗了，把借词也算成同源词，也提醒我们重新审视我们的同源词判定。Sagart et al (2019)汉藏语谱系的Densitree</p>

<figure >
    
        <img src="img/hcluster2.jpg" width="800" />
    
    
</figure>

<p>所以，我们除了看共识树以外，还要注意看densitree，densitree里有更多有用的信息。大部分人对于贝叶斯谱系分析，或者任何谱系分析的诟病都是基于最后的结论，极少注意到这些研究的数据结构和分析方法，甚至连结论都没有看全。因此，我呼吁大家除了看短短的正文，还要注意看文章的补充材料。</p>
<br>
<h2 id="贝叶斯谱系分析是不是语言学">贝叶斯谱系分析是不是语言学？<a hidden class="anchor" aria-hidden="true" href="#贝叶斯谱系分析是不是语言学">#</a></h2>
<p>语言学的贝叶斯谱系分析基本上就是如上述方式进行的，希望这样的描述足够通俗易懂。如果你们看懂了，你们可能会产生这一个疑问：究竟贝叶斯谱系分析跟传统历史语言学的结合有多紧密？这样子做出的语言谱系，究竟是不是语言学？</p>
<p>首先，我们应该明确，至少在语言学上，谱系分析的作用不是告诉我们确切的谱系，而是给我们一个有关语言谱系的参考，是辅助历史语言学研究的工具，而不能代替历史语言学本身。比如说，我们推测出的汉藏语系的谱系可以帮我们确立今后汉藏语系历史语言学研究的大方向，因为我们知道了哪些语言更可能属于同一分支，那么我们就可以根据这些线索和思路有针对性的研究。</p>
<p>贝叶斯语言谱系分析全过程中跟历史语言学有关的部分当然是前期的数据准备过程。这一过程需要历史语言学家判断同源词。如果研究对象是一个我们了解得比较深入的语系，比如印欧语系，我们判断同源词的标准当然是严格遵守历史语言学的原则的。但如果是像汉藏语系这种我们基本不了解的语系，判断同源词的时候很大程度上是靠猜测，有经验的语言学家比没有经验的一般人猜测的准确率自然会高出不少，但也不能完全保证准确。判断同源词的过程必须主要由人工处理。虽然现在也有不少判断同源词的工具和程序，但这些工具大部分基于词汇的相似性，但同源词、尤其是庞大语系下相距较远语言中的同源词往往不相似。比如拉丁语的duus和亚美尼亚语的erk是同源词，除非能把所有的音变告诉机器，否则机器是不可能把它们俩判断为同源词的。对于超级大的语系，判断同源词的工作可能长达数月，也需要好几个历史语言学家的商量与合作。做好同源词的数据后，我们就把一切复杂的计算交给电脑，等它算个几天，这一部分就脱离了传统语言学，进行纯粹统计学的计算了。</p>
<p>在得到谱系树之后，我们还可以进行后续的历史语言学研究，并把历史语言学的结论与贝叶斯谱系树进行比较。比如说，Birchall et al (2016)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_17">17]</a>就为Chapacruan语系的语言做了一个贝叶斯谱系分析，并同时使用音变创新手动得出了另一个谱系树，并对两棵树进行了比较研究，发现贝叶斯谱系分析得出的结论与手动做出的谱系树还是比较吻合的。又比如，在Sagart et al (2019)的汉藏语谱系发表后，项目成员又发表了一些后续的历史语言学研究与其遥相呼应，比如Lai et al (2020)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_18">18]</a>对西夏语谱系地位的研究，以及Jacques et Pellard (2021)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_19">19]</a>对羌缅语的分析。</p>
<p>虽然贝叶斯谱系分析的前前后后都少不了历史语言学的工作，但两者始终没有完全融合在一起，在整个研究中交集并不多，而是有着明显的分工。这一个弱点也经常被人们攻击。而且，贝叶斯谱系分析直到今天，都在使用语言学家们较为不喜欢的核心词汇作为基础，而词汇绝不能与生物学中的DNA序列相提并论，音系和形态才可以。</p>
<p>那么为什么我们坚持使用词汇呢？我在这里谈两个原因。</p>
<p>第一，词汇被认为可以涵盖历史语言学的大部分工作，并且容易操作。我们判断同源词的时候，自然要考虑到音变的规律性和对应关系，有时甚至要倒推形态，有时还要进行简单的构拟，这些工作都体现在同源词的判别中，因此我们选用词汇，并不是完全无视传统历史语言学，而是因为词汇的比较是传统历史语言学的“精华”。</p>
<p>第二，词汇的替换是可以无限进行下去的，而且词汇替换的速率已经被证明可以用一定的模型去模拟。而音变则是比较有方向性的，有的音变一旦发生，可能就没办法回头了，比如p &gt; f的音变很容易发生，而f &gt; p的音变则极少发生。另外，音变可以很快，也可以很慢，它们究竟能不能模拟也是一大问题。</p>
<p>因此，大部分语言学家在谱系分析时，都在如何更好地标记词汇上下功夫。以同源词关系为基础的谱系分析可以在较大的语系下取得成功，但如果我们要研究时间深度较浅的小分支，很可能就没那么得心应手了。</p>
<p>比如我们要研究官话的谱系，大部分官话的核心词汇都差不多，词汇替换的现象比较少，那么我们喂给机器的数据库可能大部分都是“1”，这样我们可能会得到许多平行的分支，而不是一棵有结构的树。用贝叶斯谱系分析做出的官话谱系，可能不会比白一平（2006）[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_20">20]</a>用最大简约法做出的官话谱系进步多少。再者，目前的贝叶斯分析也并非能对大语系完全掌控，比如说，Gray and Atkinson (2003)的印欧语谱系树最让人看不过眼的一点就是斯拉夫语的分类，大家可以自行上滑到他们的印欧语谱系树上，找找波兰语在哪里。</p>
<p>再举一个极端的例子，假设两种语言互相不能通话（发生了重要的音变），但所有核心词汇都是同源词，没有发生词汇替换，那么机器将认为这两种语言是同一种语言。尽管这样极端的情况在现实世界中不会发生，尽管每一种研究方法都有它的不足之处，但我们应该事先考虑到突发状况的解决办法。这就是未来我们需要解决的问题。</p>
<p>贝叶斯谱系分析在语言学上的应用已经差不多二十年了，但这二十年间，研究方法上的突破并不显著。人们当然知道这样的分析存在的问题，但是实际研究上，却很难去解决。比如在词汇替换中，有一种情况可能只有词汇的一部分被替换了，那么我们究竟是赋“1”呢，还是赋“0”呢？Hill and List (2017)[<a href="https://zhuanlan.zhihu.com/p/386454664#ref_21">21]</a>倒是提出了一个解决方案，他们开发了“部分同源词”（partial cognate）的标记方法，这种方法支持把一个词拆开，只标记同源的部分。如下图中，缅语支诸语言的“羽毛”一词，都可以分析称两个词素，我们可以把这两个词素拆开，分别标记同源关系。</p>

<figure >
    
        <img src="img/tokens.jpg" width="800" />
    
    
</figure>

<p>部分同源词的标记实际上已经向基于形态的谱系分析迈进了一步，虽然它并没有真正触及到复杂的形态变化，但至少在尝试为合成词的问题寻求合理的解决方法。部分同源词的标记通过实验证明是可行的，但是目前并没有很多真枪实弹的研究成果发表出来。</p>
<p>如果没有部分同源词的标记，贝叶斯谱系分析其实已经开始变得有点无聊，即便有了部分同源词标记，也并不能把它的有趣续命太久，毕竟这一步迈得也不大。当我们知道一个方法远没有达到理想的程度，但又不断原地打转时，我们就会自然而然地感到焦虑。</p>
<p>未来的贝叶斯谱系分析的重点必然在于我们处理数据的方式，如何融入更多的历史语言学原则是我们需要思考的。在上文中，我们已经提到，目前声称把语言学和贝叶斯谱系结合在一起的研究无非就是分别用贝叶斯做一个，再用语言学做一个，然后再进行定性的比较。这种方法是绝不能让人满意的。我们需要更加无缝的衔接。</p>
<p>另外，回归到1930年代或者Ringe et al (2002)和Nakhleh et al (2005)的“完全谱系”那种基于音系和形态特征的谱系分析似乎也是不可取的。因为这些研究对具体数据的处理完全不够，仅仅是从前人的作品里选出一部分可能对分类有用的特征进行计算，这中间仍会有许多不清晰的地方。</p>
<p>最理想的情景是从语料入手，自然地融入同源词判定以及音系、形态上的创新，让机器根据各语言创新的情况来计算出谱系树。这样不仅仅能大大增加研究的客观性和透明性——单纯的同源词判定的主观因素占比非常严重，而使用创新为依据可以让读者更直接地找出潜在的问题，而且可以让谱系分析有更强大的理论背景。</p>
<br>
<h2 id="最后">最后<a hidden class="anchor" aria-hidden="true" href="#最后">#</a></h2>
<p>恰好，昨天（2021年7月6日），我在我们所的部门会议上谈到了这个问题，Gray and Atkinson (2003)的作者之一，Russell Gray，也是我们的部门主任，也谈了他的想法。他非常愿意看到新的贝叶斯谱系的方案，不过他承认即便在印欧语的谱系研究中，完全融合语言各层面的数据也是极难做到的。我解释道我不是想完全放弃以词汇的同源关系为基础的谱系分析，而是希望能通过音系和形态，去检验词汇同源关系所无法得到的细节。我的预感是，如果我们融入了音系/形态的创新，得出的结果中，非树状信号会大大减少，并帮我们检查同源词判定究竟在哪里出现了问题。</p>
<p>流水账就写到这里吧。我想大家在这篇流水账中看到的中心思想，是通过量化谱系分析的发展史，看到研究方法一步一步的变迁，以及它们遇到的困难和存在的问题。我们应该知道，评价这类研究的重点在于它们的方法，而不仅仅局限于结论——因为结论必然是有问题的，即便我们得到了一棵完美全对的谱系树，它仍旧是存在问题的，因为它并非完全基于历史语言学理论，而很大程度基于概率，它的完美只是概率问题（有时候太漂亮的结果，也是我们担心的来源之一）。只有对数据处理的方法不断地改进，才有可能把我们带向最真实的谱系分析。</p>
<p>谱系分析是历史语言学研究中的一个强大的辅助，尤其是它自带断代的特征，可以让我们更好地追溯人类的历史。因此今后的历史语言学家对机器协助的谱系研究会更加上心，争取让既有的历史语言学理论与新兴的技术更加默契地配合。这也是我的愿望列表上的一项，在今后数年的研究中会作出各种各样的尝试。</p>
<br>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ol>
<li>Jan Czekanowski, Na Marginesie Recenzji P. K. Moszyiskiego o Ksigtce: Wstep do Historji Slowian. Lud, Series II, vol. VII (1928).</li>
<li>Kroeber, A., &amp; Chrétien, C. (1937). Quantitative Classification of Indo-European Languages. Language, 13(2), 83-103. doi:10.2307/408715</li>
<li>Guiraud, Pierre (1959), Problèmes et méthodes de la statistique linguistique, D. Reidel, Publishing Company, Dordrecht, Holland.</li>
<li>Swadesh, M. (1950). Salish internal relationships. International Journal of American Linguistics, 16(4), 157-167.</li>
<li>Ringe, D., Warnow, T., &amp; Taylor, A. (2002). Indo‐European and computational cladistics. Transactions of the philological society, 100(1), 59-129.</li>
<li>Dunn, M., Levinson, S. C., Lindström, E., Reesink, G., &amp; Terrill, A. (2008). Structural phylogeny in historical linguistics: Methodological explorations applied in Island Melanesia. Language, 710-759.</li>
<li>Bergsland, K., &amp; Vogt, H. (1962). On the validity of glottochronology. Current anthropology, 3(2), 115-153.</li>
<li>Gray, R. D., &amp; Jordan, F. M. Language trees support the express-train sequence of Austronesian expansion, 2000. Nature, 405, 1052.</li>
<li>Nakhleh, L., Ringe, D., &amp; Warnow, T. (2005). Perfect phylogenetic networks: A new methodology for reconstructing the evolutionary history of natural languages. Language, 382-420.</li>
<li>Sanderson, M. J. (1997). A nonparametric approach to estimating divergence times in the absence of rate constancy. Molecular biology and evolution, 14(12), 1218-1231.</li>
<li>Sanderson, M. 2002 Estimating absolute rates of evo- lution and divergence times: a penalized likelihood approach. Mol. Biol. Evol. 19, 101–109.</li>
<li>Zuckerkandl, E., &amp; Pauling, L. (1965). Evolutionary divergence and convergence in proteins. In Evolving genes and proteins (pp. 97-166). Academic Press.</li>
<li>Thorne, J. L., Kishino, H., &amp; Painter, I. S. (1998). Estimating the rate of evolution of the rate of molecular evolution. Molecular biology and evolution, 15(12), 1647-1657.</li>
<li>Drummond, A. J., Ho, S. Y. W., Phillips, M. J. &amp; Rambaut, A. 2006 Relaxed phylogenies and dating with confidence. PLoS Biol. 4, e88. 699 – 710. (doi:10.1371/ journal.pbio.0040088)</li>
<li>Gray, R. D., &amp; Atkinson, Q. D. (2003). Language-tree divergence times support the Anatolian theory of Indo-European origin. Nature, 426(6965), 435-439.</li>
<li>Sagart, L., Jacques, G., Lai, Y., Ryder, R. J., Thouzeau, V., Greenhill, S. J., &amp; List, J. M. (2019). Dated language phylogenies shed light on the ancestry of Sino-Tibetan. Proceedings of the National Academy of Sciences, 116(21), 10317-10322.</li>
<li>Birchall, J., Dunn, M., &amp; Greenhill, S. J. (2016). A combined comparative and phylogenetic analysis of the Chapacuran language family. International Journal of American Linguistics, 82(3), 255-284.</li>
<li>Lai, Yunfan., Gong, Xun., Gates, Jesse. P., &amp; Jacques, Guillaume. (2020). Tangut as a West Gyalrongic language. Folia Linguistica Historica, 54(s41), 171-203.</li>
<li>Jacques, G., &amp; Pellard, T. (2021). Phylogenies based on lexical innovations refute the Rung hypothesis. Diachronica, 38(1), 1-24.</li>
<li>Baxter, W. H. (2006). Mandarin dialect phylogeny. Cahiers de linguistique-Asie orientale, 35(1), 71-114.</li>
<li>Hill, N. W., &amp; List, J. M. (2017, September). Challenges of annotation and analysis in computer-assisted language comparison: A case study on Burmish languages. In Yearbook of the Poznan Linguistic Meeting (Vol. 3, No. 1, pp. 47-76). De Gruyter Open.</li>
</ol>


  </div>

  <footer class="post-footer">

  </footer><script src="https://utteranc.es/client.js"
        repo="hiDaDeng/hidadeng.github.io"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="/">大邓和他的PYTHON</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
